<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Exemple WebRTC minimal (WebSocket unifié)</title>
  <style>
    #videoContainer {
      display: flex;
      flex-wrap: wrap;
    }
    video {
      width: 300px;
      height: 225px;
      margin: 5px;
      background-color: black;
    }
    #controls {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Exemple WebRTC + send_user / send_room</h1>
  <div id="controls">
    <label>Room ID: <input id="roomInput" value="maRoomTest"></label>
    <button id="joinBtn">Rejoindre</button>
    <button id="leaveBtn" disabled>Quitter la salle</button>
  </div>
  
  <div id="videoContainer"></div>

  <script>
    const WS_URL = 'ws://localhost:8080/ws';
    let ws;
    let connectionId = null;
    let localStream = null;
    const peerConnections = {};

    const joinBtn = document.getElementById('joinBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const roomInput = document.getElementById('roomInput');

    joinBtn.addEventListener('click', async () => {
      const roomId = roomInput.value.trim();
      if (!roomId) return;
      
      // Récupérer audio/vidéo local
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        addVideoStream(localStream, "localVideo", true);
      } catch (err) {
        console.warn("Erreur getUserMedia:", err);
      }
      // Envoyer un message "join_room"
      wsSend({ type: 'join_room', room: roomId });

      // Activer le bouton "Quitter"
      joinBtn.disabled = true;
      leaveBtn.disabled = false;
    });

    leaveBtn.addEventListener('click', () => {
      const roomId = roomInput.value.trim();
      if (!roomId) return;
      wsSend({ type: 'leave_room', room: roomId });

      // Désactiver le bouton "Quitter"
      leaveBtn.disabled = true;
      joinBtn.disabled = false;
    });

    function addVideoStream(stream, elementId, isLocal) {
      let videoEl = document.getElementById(elementId);
      if (!videoEl) {
        videoEl = document.createElement('video');
        videoEl.id = elementId;
        videoEl.autoplay = true;
        videoEl.playsInline = true;
        if (isLocal) videoEl.muted = true;
        document.getElementById('videoContainer').appendChild(videoEl);
      }
      videoEl.srcObject = stream;
    }

    // ---------------------------
    // WebSocket
    // ---------------------------
    function initWebSocket() {
      ws = new WebSocket(WS_URL);
      ws.onopen = () => console.log("[CLIENT] WebSocket ouvert");
      ws.onerror = (err) => console.error("[CLIENT] WebSocket erreur:", err);
      ws.onclose = () => console.log("[CLIENT] WebSocket fermé");
      ws.onmessage = (event) => {
        let data;
        try {
          data = JSON.parse(event.data);
        } catch (e) {
          console.error("JSON invalide:", e);
          return;
        }
        handleServerMessage(data);
      };
    }

    function wsSend(obj) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(obj));
      } else {
        console.warn("WebSocket pas prêt, msg ignoré:", obj);
      }
    }

    async function handleServerMessage(data) {
      switch (data.type) {
        case 'connection_id':
          connectionId = data.connection_id;
          console.log("Mon ID =", connectionId);
          break;

        case 'joined_room':
          console.log("Rejoint la salle:", data.room);
          break;

        case 'left_room':
          console.log("Quitte la salle:", data.room);
          // Fermer toutes les peer connections
          for (let userId in peerConnections) {
            peerConnections[userId].close();
            delete peerConnections[userId];
            // Retirer la vidéo correspondante
            const videoEl = document.getElementById(`remoteVideo-${userId}`);
            if (videoEl) videoEl.remove();
          }
          break;

        case 'room_info':
          // ex: user_joined, user_left
          if (data.event === 'user_joined') {
            const newUserId = data.userId;
            console.log("Nouveau user:", newUserId);
            // Créer la PeerConnection et initier l'offer
            createPeerConnection(newUserId, true);
          } else if (data.event === 'user_left') {
            console.log("User parti:", data.userId);
            onUserDisconnected(data.userId);
          }
          break;

        case 'user_message':
          // Message direct d'un autre user
          const fromUser = data.from;
          const payload = data.payload || {};
          switch (payload.webrtc_type) {
            case 'offer':
              await onOfferReceived(fromUser, payload.offer);
              break;
            case 'answer':
              await onAnswerReceived(fromUser, payload.answer);
              break;
            case 'candidate':
              await onIceCandidateReceived(fromUser, payload.candidate);
              break;
            default:
              console.log("user_message inconnu:", payload);
          }
          break;

        default:
          console.log("Message inconnu:", data);
      }
    }

    // ---------------------------
    // WebRTC
    // ---------------------------
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    async function createPeerConnection(userId, initiator) {
      if (peerConnections[userId]) return peerConnections[userId];

      const pc = new RTCPeerConnection(rtcConfig);
      peerConnections[userId] = pc;

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          wsSend({
            type: 'send_user',
            to: userId,
            payload: {
              webrtc_type: 'candidate',
              candidate: event.candidate
            }
          });
        }
      };

      pc.ontrack = (event) => {
        const remoteStream = event.streams[0];
        console.log("Flux distant reçu:", remoteStream);
        addVideoStream(remoteStream, `remoteVideo-${userId}`, false);
      };

      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      // Si on est initiateur, on crée l'offer
      if (initiator) {
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          wsSend({
            type: 'send_user',
            to: userId,
            payload: {
              webrtc_type: 'offer',
              offer: pc.localDescription
            }
          });
        } catch (err) {
          console.error("Erreur createOffer:", err);
        }
      }

      return pc;
    }

    async function onOfferReceived(fromUser, offer) {
      const pc = await createPeerConnection(fromUser, false);
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      wsSend({
        type: 'send_user',
        to: fromUser,
        payload: {
          webrtc_type: 'answer',
          answer: pc.localDescription
        }
      });
    }

    async function onAnswerReceived(fromUser, answer) {
      const pc = peerConnections[fromUser];
      if (!pc) return;
      await pc.setRemoteDescription(new RTCSessionDescription(answer));
    }

    async function onIceCandidateReceived(fromUser, candidate) {
      const pc = peerConnections[fromUser];
      if (!pc) return;
      try {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (err) {
        console.error("Erreur addIceCandidate:", err);
      }
    }

    function onUserDisconnected(userId) {
      console.log('[CLIENT] userDisconnected =>', userId);
      const pc = peerConnections[userId];
      if (pc) {
        pc.close();
        delete peerConnections[userId];
      }
      // Retirer la vidéo correspondante
      const videoEl = document.getElementById(`remoteVideo-${userId}`);
      if (videoEl) {
        videoEl.remove();
      }
    }

    // Lancement
    initWebSocket();
  </script>
</body>
</html>
