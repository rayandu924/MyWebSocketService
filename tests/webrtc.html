<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Exemple WebRTC avec Gestion des Salles</title>
  <style>
    body { font-family: Arial, sans-serif; }
    #videoContainer { display: flex; flex-wrap: wrap; gap: 10px; }
    video { width: 300px; height: 225px; background: black; }
    #roomsList { margin-top: 20px; }
    #roomsList ul { list-style: none; padding: 0; }
    #roomsList li { margin: 5px 0; }
  </style>
</head>
<body>
  <h1>Exemple WebRTC avec Gestion des Salles</h1>
  
  <div>
    <label>Room ID: <input id="roomInput" value="maRoomTest"></label>
    <button id="joinBtn">Rejoindre</button>
    <button id="leaveBtn" disabled>Quitter</button>
  </div>
  
  <div id="roomsList">
    <h2>Salles Actives</h2>
    <ul id="activeRooms"></ul>
  </div>
  
  <div id="videoContainer"></div>

  <script>
    const WS_URL = 'ws://localhost:8080/ws';
    let ws;
    let connectionId = null;
    let currentRoom = null;
    let localStream = null;
    const peerConnections = {};

    const joinBtn = document.getElementById('joinBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const roomInput = document.getElementById('roomInput');
    const activeRoomsList = document.getElementById('activeRooms');

    joinBtn.addEventListener('click', async () => {
      const roomId = roomInput.value.trim();
      if (!roomId) {
        alert("Veuillez entrer un nom de salle.");
        return;
      }
      // Établir la connexion WebSocket si ce n'est pas déjà fait
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        initWebSocket();
      }
      // Rejoindre la salle
      wsSend({ type: 'join_room', room: roomId });
    });

    leaveBtn.addEventListener('click', () => {
      if (currentRoom) {
        wsSend({ type: 'leave_room', room: currentRoom });
        currentRoom = null;
        leaveBtn.disabled = true;
        joinBtn.disabled = false;
      }
    });

    function addVideoStream(stream, elementId, isLocal) {
      let videoEl = document.getElementById(elementId);
      if (!videoEl) {
        videoEl = document.createElement('video');
        videoEl.id = elementId;
        videoEl.autoplay = true;
        videoEl.playsInline = true;
        if (isLocal) videoEl.muted = true;
        document.getElementById('videoContainer').appendChild(videoEl);
      }
      videoEl.srcObject = stream;
    }

    // ---------------------------
    // WebSocket
    // ---------------------------
    function initWebSocket() {
      ws = new WebSocket(WS_URL);
      ws.onopen = () => {
        console.log("[CLIENT] WebSocket ouvert");
      };
      ws.onerror = (err) => {
        console.error("[CLIENT] WebSocket erreur:", err);
      };
      ws.onclose = () => {
        console.log("[CLIENT] WebSocket fermé");
      };
      ws.onmessage = (event) => {
        let data;
        try {
          data = JSON.parse(event.data);
        } catch (e) {
          console.error("JSON invalide:", e);
          return;
        }
        handleServerMessage(data);
      };
    }

    function wsSend(obj) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(obj));
      } else {
        console.warn("WebSocket pas prêt, message ignoré:", obj);
      }
    }

    async function handleServerMessage(data) {
      switch (data.type) {
        case 'connection_id':
          connectionId = data.connection_id;
          console.log("Mon ID =", connectionId);
          break;

        case 'joined_room':
          console.log("Rejoint la salle:", data.room);
          currentRoom = data.room;
          joinBtn.disabled = true;
          leaveBtn.disabled = false;
          // Récupérer audio/vidéo local si ce n'est pas déjà fait
          if (!localStream) {
            try {
              localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
              addVideoStream(localStream, "localVideo", true);
            } catch (err) {
              console.warn("Erreur getUserMedia:", err);
            }
          }
          break;

        case 'left_room':
          console.log("A quitté la salle:", data.room);
          // Nettoyer les connexions peer et les vidéos
          for (let userId in peerConnections) {
            onUserDisconnected(userId);
          }
          if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
            const localVideo = document.getElementById("localVideo");
            if (localVideo) localVideo.remove();
          }
          break;

        case 'active_rooms':
          updateActiveRooms(data.rooms);
          break;

        case 'room_info':
          // ex: user_joined, user_left
          if (data.event === 'user_joined') {
            const newUserId = data.userId;
            if (newUserId === connectionId) return; // Ignorer si c'est soi-même
            console.log("Nouveau user dans la salle:", newUserId);
            // Créer la PeerConnection et initier l'offer
            createPeerConnection(newUserId, true);
          } else if (data.event === 'user_left') {
            console.log("User parti de la salle:", data.userId);
            onUserDisconnected(data.userId);
          }
          break;

        case 'user_message':
          // Message direct d'un autre user
          const fromUser = data.from;
          const payload = data.payload || {};
          switch (payload.webrtc_type) {
            case 'offer':
              await onOfferReceived(fromUser, payload.offer);
              break;
            case 'answer':
              await onAnswerReceived(fromUser, payload.answer);
              break;
            case 'candidate':
              await onIceCandidateReceived(fromUser, payload.candidate);
              break;
            default:
              console.log("user_message inconnu:", payload);
          }
          break;

        case 'error':
          console.error("Erreur du serveur:", data.message);
          break;

        default:
          console.log("Message inconnu du serveur:", data);
      }
    }

    function updateActiveRooms(rooms) {
      activeRoomsList.innerHTML = '';
      for (let room in rooms) {
        const li = document.createElement('li');
        li.textContent = `${room} (${rooms[room].length} utilisateurs)`;
        activeRoomsList.appendChild(li);
      }
    }

    // ---------------------------
    // WebRTC
    // ---------------------------
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    async function createPeerConnection(userId, initiator) {
      if (peerConnections[userId]) return peerConnections[userId];

      const pc = new RTCPeerConnection(rtcConfig);
      peerConnections[userId] = pc;

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          wsSend({
            type: 'send_user',
            to: userId,
            payload: {
              webrtc_type: 'candidate',
              candidate: event.candidate
            }
          });
        }
      };

      pc.ontrack = (event) => {
        const remoteStream = event.streams[0];
        console.log("Flux distant reçu de", userId, ":", remoteStream);
        addVideoStream(remoteStream, `remoteVideo-${userId}`, false);
      };

      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      // Si initiateur, créer et envoyer l'offre
      if (initiator) {
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          wsSend({
            type: 'send_user',
            to: userId,
            payload: {
              webrtc_type: 'offer',
              offer: pc.localDescription
            }
          });
        } catch (err) {
          console.error("Erreur createOffer:", err);
        }
      }

      return pc;
    }

    async function onOfferReceived(fromUser, offer) {
      const pc = await createPeerConnection(fromUser, false);
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        wsSend({
          type: 'send_user',
          to: fromUser,
          payload: {
            webrtc_type: 'answer',
            answer: pc.localDescription
          }
        });
      } catch (err) {
        console.error("Erreur lors du traitement de l'offre:", err);
      }
    }

    async function onAnswerReceived(fromUser, answer) {
      const pc = peerConnections[fromUser];
      if (!pc) {
        console.warn("PeerConnection non trouvée pour l'utilisateur:", fromUser);
        return;
      }
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
      } catch (err) {
        console.error("Erreur setRemoteDescription (answer):", err);
      }
    }

    async function onIceCandidateReceived(fromUser, candidate) {
      const pc = peerConnections[fromUser];
      if (!pc) {
        console.warn("PeerConnection non trouvée pour l'utilisateur:", fromUser);
        return;
      }
      try {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (err) {
        console.error("Erreur addIceCandidate:", err);
      }
    }

    function onUserDisconnected(userId) {
      const pc = peerConnections[userId];
      if (pc) {
        pc.close();
        delete peerConnections[userId];
      }
      const videoEl = document.getElementById(`remoteVideo-${userId}`);
      if (videoEl) videoEl.remove();
      console.log("Nettoyé les ressources pour l'utilisateur:", userId);
    }

    // Nettoyage lors de la fermeture de la page
    window.addEventListener('beforeunload', () => {
      if (currentRoom) {
        wsSend({ type: 'leave_room', room: currentRoom });
      }
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
      for (let userId in peerConnections) {
        onUserDisconnected(userId);
      }
    });

    // Lancement initial
    initWebSocket();
  </script>
</body>
</html>
